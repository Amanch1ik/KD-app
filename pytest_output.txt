FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF                                        [100%]
================================== FAILURES ===================================
____________ InternationalizationTestCase.test_admin_translations _____________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_admin_translations>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F102FF550>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
___________ InternationalizationTestCase.test_category_translations ___________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_category_translations>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F103416C0>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
___________ InternationalizationTestCase.test_gettext_translations ____________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_gettext_translations>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F103432B0>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
____________ InternationalizationTestCase.test_language_middleware ____________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_language_middleware>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F10342D40>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
___________ InternationalizationTestCase.test_product_translations ____________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_product_translations>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F10205210>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
__________ InternationalizationTestCase.test_restaurant_translations __________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_restaurant_translations>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F10207EB0>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
__________ InternationalizationTestCase.test_serializer_translations __________

self = <delivery.tests.test_internationalization.InternationalizationTestCase testMethod=test_serializer_translations>

    def setUp(self):
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√х юс·хъЄ√ ё яхЁхтюфрьш
>       self.category = Category.objects.create(
            name='╘рёЄ-Їєф',
            name_ru='╘рёЄ-Їєф',
            name_ky='╥хч Єрьръ',
            name_en='Fast Food'
        )

delivery\tests\test_internationalization.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\django\db\models\manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\Lib\site-packages\django\db\models\query.py:656: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Category: ╘рёЄ-Їєф>, args = ()
kwargs = {'name_en': 'Fast Food', 'name_ky': '╥хч Єрьръ', 'name_ru': '╘рёЄ-Їєф'}
cls = <class 'delivery.models.Category'>, opts = <Options for Category>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x0000023F103C9960>, val = None
field = <django.db.models.fields.TextField: description>
is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
>               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: Category() got unexpected keyword arguments: 'name_ru', 'name_ky', 'name_en'

venv\Lib\site-packages\django\db\models\base.py:567: TypeError
____________________ ModelTestCase.test_category_creation _____________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_category_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_________________ ModelTestCase.test_delivery_person_creation _________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_delivery_person_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_____________________ ModelTestCase.test_model_validation _____________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_model_validation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
______________________ ModelTestCase.test_order_creation ______________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_order_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_____________________ ModelTestCase.test_product_creation _____________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_product_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_____________________ ModelTestCase.test_rating_creation ______________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_rating_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
___________________ ModelTestCase.test_restaurant_creation ____________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_restaurant_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
__________________ ModelTestCase.test_user_profile_creation ___________________

self = <delivery.tests.test_models.ModelTestCase testMethod=test_user_profile_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_models.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
________________ UserProfileModelTest.test_create_user_profile ________________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_create_user_profile>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_____________ UserProfileModelTest.test_date_of_birth_validation ______________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_date_of_birth_validation>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_________________ UserProfileModelTest.test_email_validation __________________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_email_validation>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_______________ UserProfileModelTest.test_notification_settings _______________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_notification_settings>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_________________ UserProfileModelTest.test_order_preferences _________________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_order_preferences>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
______________ UserProfileModelTest.test_phone_number_validation ______________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_phone_number_validation>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
____________ UserProfileModelTest.test_profile_picture_validation _____________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_profile_picture_validation>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
______________ UserProfileModelTest.test_social_links_validation ______________

self = <delivery.tests.test_models.UserProfileModelTest testMethod=test_social_links_validation>

    def setUp(self):
        """
        ╧юфуюЄютър фрээ√ї фы  ЄхёЄшЁютрэш 
        """
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )

delivery\tests\test_models.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
________________ ServiceTestCase.test_assign_available_courier ________________

self = <delivery.tests.test_services.ServiceTestCase testMethod=test_assign_available_courier>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_services.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_________________ ServiceTestCase.test_calculate_delivery_fee _________________

self = <delivery.tests.test_services.ServiceTestCase testMethod=test_calculate_delivery_fee>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_services.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
________________ ServiceTestCase.test_validate_order_creation _________________

self = <delivery.tests.test_services.ServiceTestCase testMethod=test_validate_order_creation>

    def setUp(self):
        # ╤ючфрэшх ЄхёЄют√ї фрээ√ї
>       self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )

delivery\tests\test_services.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_________________ ViewTestCase.test_courier_order_assignment __________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_courier_order_assignment>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
______________________ ViewTestCase.test_order_creation _______________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_order_creation>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_______________________ ViewTestCase.test_product_list ________________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_product_list>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
____________________ ViewTestCase.test_unauthorized_access ____________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_unauthorized_access>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
________________________ ViewTestCase.test_user_login _________________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_user_login>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
____________________ ViewTestCase.test_user_profile_update ____________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_user_profile_update>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
_____________________ ViewTestCase.test_user_registration _____________________

self = <delivery.tests.test_views.ViewTestCase testMethod=test_user_registration>

    def setUp(self):
        # ╤ючфрхь ъышхэЄ фы  ЄхёЄшЁютрэш  API
        self.client = APIClient()
    
        # ╤ючфрхь ЄхёЄют√ї яюы№чютрЄхыхщ
>       self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpassword123'
        )

delivery\tests\test_views.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.ManagerDescriptor object at 0x0000023F0E7DAD50>
instance = None, cls = <class 'django.contrib.auth.models.User'>

    def __get__(self, instance, cls=None):
        if instance is not None:
            raise AttributeError(
                "Manager isn't accessible via %s instances" % cls.__name__
            )
    
        if cls._meta.abstract:
            raise AttributeError(
                "Manager isn't available; %s is abstract" % (cls._meta.object_name,)
            )
    
        if cls._meta.swapped:
>           raise AttributeError(
                "Manager isn't available; '%s' has been swapped for '%s'"
                % (
                    cls._meta.label,
                    cls._meta.swapped,
                )
            )
E           AttributeError: Manager isn't available; 'auth.User' has been swapped for 'delivery.CustomUser'

venv\Lib\site-packages\django\db\models\manager.py:196: AttributeError
============================== warnings summary ===============================
venv\Lib\site-packages\django\conf\__init__.py:267
  D:\Karakol-delivery-backend\venv\Lib\site-packages\django\conf\__init__.py:267: RemovedInDjango50Warning: The USE_L10N setting is deprecated. Starting with Django 5.0, localized formatting of data will always be enabled. For example Django will display numbers and dates using the format of the current locale.
    warnings.warn(USE_L10N_DEPRECATED_MSG, RemovedInDjango50Warning)

venv\Lib\site-packages\drf_yasg\__init__.py:2
  D:\Karakol-delivery-backend\venv\Lib\site-packages\drf_yasg\__init__.py:2: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
    from pkg_resources import DistributionNotFound, get_distribution

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_admin_translations
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_category_translations
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_gettext_translations
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_language_middleware
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_product_translations
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_restaurant_translations
FAILED delivery/tests/test_internationalization.py::InternationalizationTestCase::test_serializer_translations
FAILED delivery/tests/test_models.py::ModelTestCase::test_category_creation
FAILED delivery/tests/test_models.py::ModelTestCase::test_delivery_person_creation
FAILED delivery/tests/test_models.py::ModelTestCase::test_model_validation - ...
FAILED delivery/tests/test_models.py::ModelTestCase::test_order_creation - At...
FAILED delivery/tests/test_models.py::ModelTestCase::test_product_creation - ...
FAILED delivery/tests/test_models.py::ModelTestCase::test_rating_creation - A...
FAILED delivery/tests/test_models.py::ModelTestCase::test_restaurant_creation
FAILED delivery/tests/test_models.py::ModelTestCase::test_user_profile_creation
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_create_user_profile
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_date_of_birth_validation
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_email_validation
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_notification_settings
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_order_preferences
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_phone_number_validation
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_profile_picture_validation
FAILED delivery/tests/test_models.py::UserProfileModelTest::test_social_links_validation
FAILED delivery/tests/test_services.py::ServiceTestCase::test_assign_available_courier
FAILED delivery/tests/test_services.py::ServiceTestCase::test_calculate_delivery_fee
FAILED delivery/tests/test_services.py::ServiceTestCase::test_validate_order_creation
FAILED delivery/tests/test_views.py::ViewTestCase::test_courier_order_assignment
FAILED delivery/tests/test_views.py::ViewTestCase::test_order_creation - Attr...
FAILED delivery/tests/test_views.py::ViewTestCase::test_product_list - Attrib...
FAILED delivery/tests/test_views.py::ViewTestCase::test_unauthorized_access
FAILED delivery/tests/test_views.py::ViewTestCase::test_user_login - Attribut...
FAILED delivery/tests/test_views.py::ViewTestCase::test_user_profile_update
FAILED delivery/tests/test_views.py::ViewTestCase::test_user_registration - A...
33 failed, 2 warnings in 5.36s
